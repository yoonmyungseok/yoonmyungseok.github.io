---
title: "[정처기 실기]2. 현행 시스템 파악"
excerpt: 요구사항 확인
categories:
- Study
tags:
- [정보처리기사, 정보처리기사 실기]
toc: false
toc_sticky: false
toc_label: "정보처리기사 실기"
date: '2022-03-13 12:00:00'
last_modified_at: '2022-03-13'
published: true
---

> _수제비 2022 정보처리기사 실기 수험서를 보고 공부한 기록입니다._

---

## **\[현행 시스템 파악 개념\]**

-   현행 시스템 파악이란 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 제공 기능 및 연계 정보는 무엇이며 어떤 기술 요소를 사용하는지를 파악하는 활동이다
-   사용하고 있는 소프트웨어 및 하드웨어는 무엇인지, 네트워크의 구성은 어떻게 되어 있는지 파악하는 활동이다

## **\[현행 시스템 파악 절차\]**

1단계: 구성 / 기능 / 인터페이스 파악

-   시스템 구성 현황 파악
-   시스템 기능 파악
-   시스템 인터페이스 현황 파악

2단계: 아키텍처 및 소프트웨어 구성 파악

-   아키텍처 파악
-   소프트웨어 구성 파악

3단계: 하드웨어 및 네트워크 구성 파악

-   시스템 하드웨어 현황 파악
-   네트워크 구성 파악

### 1\. 현행 시스템 구성/기능 및 인터페이스 파악

| **절차** | **설명** | **작성 시 고려 사항** |
| --- | --- | --- |
| 현행 시스템 구성 현황 파악 | 조직의 주요 업무를 처리하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 파악 | \-각 업무에 속하는 정보 시스템들의 명칭, 주요 기능들을 명시   \-조직 내 존재하는 모든 정보시스템의 현황 파악이 가능하도록 함 |
| 기능 현황 파악 | 단위 업무 시스템이 현재 제공하고 있는 기능 파악 | 단위 업무 시스템 기능들을 주요 기능과 하부 기능으로 구분하여 계층 형으로 표시 |
| 인터페이스 현황 파악 | 단위 업무 시스템이 다른 시스템과 주고 받는 데이터의 종류, 데이터 형식, 프로토콜, 연계유형, 주기 파악 | 데이터 형식(XML, 고정 포맷, 가변 포맷 등)을 주고 받는지, 어떤 통신규약(TCP/IP, X.25등)을 사용하고 있고, 연계유형(EAI 등)은 무엇인지 등을 표시 |

### 2\. 현행 시스템 아키텍처 및 소프트웨어 구성 파악

| **절차** | **설명** | **작성 시 고려 사항** |
| --- | --- | --- |
| 현행 시스템 아키텍처 구성 파악 | 기간 업무를 수행하기 위하여 계층별로 어떠한 기술 요소들을 사용하고 있는지 최상위 수준에서 파악 | 단위 업무 시스템별로 아키텍처가 다른 경우에는 가장 핵심이 되는 기간 업무 처리 시스템을 기준으로 파악 |
| 소프트웨어 구성 파악 | 단위 업무 시스템의 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 파악 | 상용 소프트웨어의 경우에는 라이선스 적용 방식의 기준(사이트, 서버, 프로세서, 코어, 사용자 수 등)과 보유한 라이선스 수량 파악 중요 |

### 3\. 하드웨어 및 네트워크 구성 파악

| **절차** | **설명** | **작성 시 고려 사항** |
| --- | --- | --- |
| 하드웨어 구성 파악 | 단위 업무 시스템들이 운용되고 있는 서버의 위치, 운용 서버의 주요 사양(CPU 처리속도, 메모리 크기, 하드디스크의 용량 등)과 수량, 이중화 구현 여부를 파악 | 이중화는 기간 업무의 서비스 기간, 장애 대응 정책에 따라 필요성 여부가 결정되며, 이에 따라 인프라 구축 기술 난이도 및 비용 증가 가능성이 존재 |
| 네트워크 구성 파악 | 업무 처리 시스템을 위해 어떤 네트워크 장비를 사용하여 어떻게 구성되어 있는지 파악 | 네트워크 구성도의 작성을 통해 서버의 위치, 서버 간의 네트워크 연결 방식을 파악할 수 있도록 표현 |

## **\[소프트웨어 아키텍처\]**

### 1\. 소프트웨어 아키텍처(Software Architecture) 개념

-   소프트웨어 아키텍처는 여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템의 구조나 구조체이다

### 2\. 소프트웨어 아키텍처 프레임워크

#### 소프트웨어 아키텍처 프레임워크(Software Architecture Framework) 개념

-   소프트웨어 아키텍처 프레임워크는 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준이다

#### 소프트웨어 아키텍처 프레임워크 구성요소

-   아키텍처 명세서(Architectural Description)
    -   아키텍처를 기록하기 위한 산출물들
    -   이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현
    -   개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음
-   이해관계자(Stakeholder)
    -   시스템 개발에 관련된 모든 사람과 조직
    -   고객, 최종사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등을 포함
-   관심사(Concerns)
    -   사용자 입장: 기본적인 기능, 신뢰성, 보안, 사용성 등의 품질
    -   유지보수자 입장: 유지보수의 용이성
    -   개발자 입장: 적은 비용과 인력으로 개발
-   관점(Viewpoint)
    -   개별 뷰를 개발할 때 토대가 되는 패턴이나 양식
    -   이해관계자들이 서로 다른 역할이나 책임으로 시스템이나 산출물들에 대해 보고 싶은 관점
-   뷰(View)
    -   서로 관련 있는 관심사들의 집합이라는 관점에서 전체 시스템을 표현
    -   시스템에 대한 아키텍처 설명에는 하나 이상의 뷰로 구성
-   근거(Rationale)
    -   아키텍처 결정 근거
    -   회의 결과, 보고 결과
-   목표(Mission)
    -   환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용, 운영 방법
-   환경(Environment)
    -   시스템에 영향을 주는 요인으로 개발, 운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인
-   시스템(System)
    -   각 애플리케이션, 서브 시스템, 시스템의 집합, 제품군 등의 구현체

### 3\. 소프트웨어 아키텍처 4+1 뷰

#### 소프트웨어 아키텍처 4+1뷰 개념

-   소프트웨어 아키텍처 4+1 뷰는 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법이다
-   4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개 구조가 서로 충돌되지 않는지, 시스템의 요구사항을 충족시키는지를 증명하기 위해 체크 방법으로 유스케이스를 사용한다

#### 소프트웨어 아키텍처 4+1 뷰 구성요소

-   4+1에서 1은 유스케이스 뷰이고 4는 논리 뷰, 구현 뷰, 프로세스 뷰, 배포 뷰다
-   유스케이스 뷰(Usecase View)
    -   유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는 데 사용되는 뷰
    -   사용자, 설계자, 개발자, 테스트 관점
-   논리 뷰(Logical View)
    -   시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
    -   설계자, 개발자 관점
-   프로세스 뷰(Process View)
    -   시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
    -   개발자, 시스템 통합자 관점
-   구현 뷰(Implementation View)
    -   개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
    -   컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관한 부가적인 정보 정의
-   배포 뷰(Deployment View)
    -   컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰

### 4\. 소프트웨어 아키텍처 패턴

#### 소프트웨어 아키텍처 패턴(Software Architecture Pattern) 개념

-   소프트웨어 아키텍처 패턴은 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식이다
-   주어진 상황에서의 소프트웨어 아키텍처에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션이다

#### 소프트웨어 아키텍처 패턴 필요성

-   소프트웨어 개발 시 상황별 소프트웨어 아키텍처 패턴을 수립 적용하여 고객과 의사소통을 통해 고객의 요구사항을 만족시키고, 소프트웨어 개발 생산성과 품질 확보가 가능하다
-   개발에 대한 시행착오를 줄여 개발 시간을 단축하고, 높은 품질의 소프트웨어 생산이 가능하다
-   이미 검증된 구조로 개발하기 때문에 소프트웨어 개발을 안정적으로 수행할 수 있다
-   시스템의 특성을 개발 전에 예측이 가능하다

#### 소프트웨어 아키텍처 패턴 유형

-   **계층화 패턴(Layered Pattern)**  
    -   계층화 패턴은 시스템을 계층(Layer)으로 구분하여 구성하는 패턴
    -   각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공
    -   계층화 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어짐
-   **클라이언트-서버 패턴(Client-Server Pattern)**
    -   클라이언트-서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된 패턴
    -   사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스를 제공
    -   서버는 계속 클라이언트로부터 요청을 대기
-   **파이프-필터 패턴(Pipe-Filter Pattern)**
    -   파이프-필터 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 패턴
    -   파이프-필터 패턴은 서브 시스템이 입력 데이터를 받아 처리하고, 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
    -   필터 컴포넌트는 재사용성이 좋고, 추가가 쉽기 때문에 확장이 용이
-   **브로커 패턴(Broker Pattern)**
    -   브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고, 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
    -   브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행
    -   서버는 자신의 기능들(서비스 및 특성)을 브로커에 넘겨주며(Publish), 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리다이렉션(Redirection) 함
-   **모델-뷰-컨트롤러 패턴(MVC; Model View Controller Pattern)**
    -   모델(Model): 핵심 기능과 데이터 보관
    -   뷰(View): 사용자에게 정보 표시(하나 이상의 뷰가 정의될 수 있음)
    -   컨트롤러(Controller): 사용자로부터 요청을 입력받아 처리
    -   MVC 패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어서 서로 영향을 받지 않고 개발 작업 수행 가능
    -   MVC 패턴은 컴포넌트를 분리하며 코드의 효율적인 재사용을 가능하게 하고, 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합

### 5\. 소프트웨어 아키텍처 비용 평가 모델

#### 소프트웨어 아키텍처 비용 평가 모델 개념

-   소프트웨어 아키텍처 비용 평가 모델은 아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델이다

#### 소프트웨어 아키텍처 비용 평가 모델 종류

| **종류** | **설명** |
| --- | --- |
| SAAM   (Software Architecture Analysis Method) | 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능한 비용 평가 모델 |
| ATAM   (Architecture Trade-off Analysis Method) | 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델 |
| CBAM   (Cost Benefit Analysis Method) | ATAM 바탕의 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델 |
| ADR   (Active Design Review) | 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델 |
| ARID   (Active Reviews for Intermediate Designs) | 전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델 |

## **\[디자인 패턴\]**

### 1\. 디자인 패턴(Design Pattern) 개념

-   디자인 패턴은 소프트웨어 공학의 소프트웨어 설계에서 공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴이다
-   디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지보수성, 운용성이 높아지며, 프로그램의 최적화에 도움이 된다

### 2\. 디자인 패턴 구성요소

-   **패턴의 이름**: 디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형
-   **문제 및 배경**: 디자인 패턴이 사용되는 분야 또는 배경, 해결하는 문제를 의미
-   **솔루션**: 디자인 패턴을 이루는 요소들, 관계, 협동 과정
-   **사례**: 디자인 패턴의 간단한 적용 사례
-   **결과**: 디자인 패턴을 사용하면 얻게 되는 이점이나 영향
-   **샘플** **코드**: 디자인 패턴이 적용된 원시 코드

### 3\. 디자인 패턴 유형

| **구분**  | **유형** | **설명** |
| --- | --- | --- |
| 목적 | 생성 | \-객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴 |
| |구조 | \-더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴 |
| |행위 | \-클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴 |
| 범위 | 클래스 | \-클래스 간 관련성(상속 관계를 다루는 패턴)   \-컴파일 타임에 정적으로 결정 |
| |객체 | \-객체 간 관련성을 다루는 패턴   \-런타임에 동적으로 결정 |

### 4\. 디자인 패턴 종류

#### ▶생성 패턴

-   Builder
    -   복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
    -   생성과 표기를 분리해서 복잡한 객체를 생성
-   Prototype
    -   처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴
    -   기존 객체를 복제함으로써 객체를 생성
-   Factory Method
    -   상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴
    -   생성할 객체의 클래스를 국한하지 않고 객체를 생성
-   Abstract Factory
    -   구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스(API)를 제공하고, 구체적인 구현은 Concrete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴
    -   동일한 주제의 다른 팩토리를 묶음
-   Singleton
    -   전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
    -   한 클래스에 한 객체만 존재하도록 제한

#### ▶구조 패턴

-   Bridge
    -   기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
    -   구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용
-   Decorator
    -   기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴으로 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴
    -   객체의 결합을 통해 기능을 동적으로 유연하게 확장
-   Facade
    -   복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있는 디자인 패턴
    -   통합된 인터페이스 제공
-   Flyweight
    -   다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리를 절약하고, '클래스의 경량화'를 목적으로 하는 디자인 패턴
    -   여러 개의 '가상 인스턴스'를 제공하여 메모리 절감
-   Proxy
    -   '실제 객체에 대한 대리 객체'로 실제 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실제 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴
    -   특정 객체로의 접근을 제어하기 위한 용도로 사용
-   Composite
    -   객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
    -   복합 객체와 단일 객체를 동일하게 취급
-   Adapter
    -   기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴
    -   인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

#### ▶행위 패턴

-   Mediator
    -   객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 디자인 패턴
    -   상호 작용의 유연한 변경을 지원
-   Interpreter
    -   언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴
    -   문법 자체를 캡슐화하여 사용
-   Iterator
    -   컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
    -   내부구조를 노출하지 않고, 복합 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴
-   Template Method
    -   어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스(추상 클래스)에는 추상 메소드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메소드에는 세부 처리를 구체화하는 방식으로 사용하여 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴
    -   상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행
-   Observer
    -   한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴
    -   객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존
-   State
    -   객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는 디자인 패턴
    -   객체의 상태에 따라 행위 내용을 변경
-   Visitor
    -   각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메소드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴
    -   특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
-   Command
    -   실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메소드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴
    -   요구사항을 객체로 캡슐화
-   Strategy
    -   알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴
    -   행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
-   Memento
    -   클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 Undo 기능을 개발할 때 사용하는 디자인 패턴
    -   객체를 이전 상태로 복수시켜야 하는 경우, '작업취소(Undo)' 요청 가능
-   Chain of Rsponsibility
    -   정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴
    -   한 요청을 2개 이상의 객체에서 처리

## **\[현행 시스템 분석서 작성 및 검토\]**

### 1\. 현행 시스템 관련 자료 수집

-   현행 시스템 관련 자료 수집을 위해서 수집 자료의 특성에 따라 3개의 팀을 구성한다
-   3개의 팀 구성 및 취득할 자료 목록은 아래와 같다

| **팀 구성** | **취득 자료 목록** |
| --- | --- |
| 정보시스템 구성/기능 및 인터페이스 자료 수집팀 | \-정보 시스템 구성도   \-정보시스템 기능 구성도   \-정보시스템 인터페이스 현황 |
| 현행 시스템 아키텍처 및 소프트웨어 자료 수집팀 | \-현행 시스템 아키텍처 구성도   \-소프트웨어 구성도 |
| 하드웨어 및 네트워크 자료 수집팀 | \-하드웨어 구성도   \-네트워크 구성도 |

-   수집 자료의 성격에 따라서 팀을 명확하게 구분하는 것이 필요하다

### 2\. 수집 자료의 분석

-   수집된 정보들을 취합/정제하고, 중복되거나 유효하지 않은 정보들은 삭제한다
-   불명확한 부분은 체크한 후 분석 및 설계 단계를 통해 구체적으로 조사한다
-   현행 시스템의 이슈 및 문제점을 파악한다

| **팀 구성** | **취득 자료 목록** | **분석 대상** |
| --- | --- | --- |
| 정보시스템 구성/기능 및 인터페이스 자료 수집팀 | 정보시스템 구성/기능 구성도 | \-정보시스템의 구분   \-정보시스템명   \-주요 기능   \-정보시스템의 기능 구성 |
| 인터페이스 현황 | \-송수신 시스템   \-연계 방식 및 연계 주기   \-연동 데이터 형식   \-주요 연동 데이터 |
| 현행 시스템 아키텍처 및 소프트웨어 자료 수집팀 | 현행 시스템 아키텍처 구성도 | \-운영체제의 종류   \-적용 프레임워크   \-계층별 적용 기술   \-데이터 연동 방식   \-데이터 저장소   \-외부 시스템 연계 방식 |
| 소프트웨어 구성도 | \-단위 시스템별 필요 소프트웨어의 제품명 및 용도   \-라이선스 적용 방식   \-라이선스 수 |
| 하드웨어 및 네트워크 자료 수집팀 | 하드웨어 구성도 | \-단위 시스템별 서버 제품명 및 용도   \-CPU/메모리/하드디스크 용량 및 수량   \-이중화 적용 여부 |
| 네트워크 구성도 | \-네트워크 장비의 용도 및 제품명   \-네트워크 장비 수량 및 주요 사양   \-네트워크 장비 위치 및 연동 프로토콜 |

### 3\. 분석한 결과를 기반으로 산출물 작성

-   각 취득 자료를 분석한 결과를 기반으로 산출물을 작성한다
-   현행 시스템의 이슈나 문제점을 산출물에 상세하게 포함하여 작성한다

### 4\. 산출물에 대한 검토 수행

-   팀별로 작성된 산출물을 상호 검토하여 의견을 제시한다
-   다른 팀의 검토의견을 반영하여 산출물을 수정하고 최종 완료한다